# coding: utf-8

"""
    Masking API

    Schema for the Continuous Compliance Engine API  # noqa: E501

    OpenAPI spec version: 5.1.18
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from dxm.lib.masking_api.api_client import ApiClient


class AlgorithmApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_algorithm(self, body, **kwargs):  # noqa: E501
        """Create algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_algorithm(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Algorithm body: The algorithm to create (required)
        :return: AsyncTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_algorithm_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_algorithm_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_algorithm_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_algorithm_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Algorithm body: The algorithm to create (required)
        :return: AsyncTask
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_algorithm" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `create_algorithm`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_algorithm(self, algorithm_name, **kwargs):  # noqa: E501
        """Delete algorithm by name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_algorithm(algorithm_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str algorithm_name: The name of the algorithm to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_algorithm_with_http_info(algorithm_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_algorithm_with_http_info(algorithm_name, **kwargs)  # noqa: E501
            return data

    def delete_algorithm_with_http_info(self, algorithm_name, **kwargs):  # noqa: E501
        """Delete algorithm by name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_algorithm_with_http_info(algorithm_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str algorithm_name: The name of the algorithm to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['algorithm_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_algorithm" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'algorithm_name' is set
        if self.api_client.client_side_validation and ('algorithm_name' not in params or
                                                       params['algorithm_name'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `algorithm_name` when calling `delete_algorithm`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'algorithm_name' in params:
            path_params['algorithmName'] = params['algorithm_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{algorithmName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def export_values(self, algorithm_name, **kwargs):  # noqa: E501
        """Export lookup values for secure lookup algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_values(algorithm_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str algorithm_name: The name of the algorithm (required)
        :return: AsyncTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.export_values_with_http_info(algorithm_name, **kwargs)  # noqa: E501
        else:
            (data) = self.export_values_with_http_info(algorithm_name, **kwargs)  # noqa: E501
            return data

    def export_values_with_http_info(self, algorithm_name, **kwargs):  # noqa: E501
        """Export lookup values for secure lookup algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_values_with_http_info(algorithm_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str algorithm_name: The name of the algorithm (required)
        :return: AsyncTask
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['algorithm_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_values" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'algorithm_name' is set
        if self.api_client.client_side_validation and ('algorithm_name' not in params or
                                                       params['algorithm_name'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `algorithm_name` when calling `export_values`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'algorithm_name' in params:
            path_params['algorithmName'] = params['algorithm_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{algorithmName}/export-lookup-values', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_algorithm(self, algorithm_name, **kwargs):  # noqa: E501
        """Get algorithm by name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm(algorithm_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str algorithm_name: The name of the algorithm to get (required)
        :return: Algorithm
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_algorithm_with_http_info(algorithm_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_algorithm_with_http_info(algorithm_name, **kwargs)  # noqa: E501
            return data

    def get_algorithm_with_http_info(self, algorithm_name, **kwargs):  # noqa: E501
        """Get algorithm by name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_with_http_info(algorithm_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str algorithm_name: The name of the algorithm to get (required)
        :return: Algorithm
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['algorithm_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_algorithm" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'algorithm_name' is set
        if self.api_client.client_side_validation and ('algorithm_name' not in params or
                                                       params['algorithm_name'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `algorithm_name` when calling `get_algorithm`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'algorithm_name' in params:
            path_params['algorithmName'] = params['algorithm_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{algorithmName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Algorithm',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_algorithm_framework(self, framework_id, **kwargs):  # noqa: E501
        """Get algorithm framework by frameworkId  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_framework(framework_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int framework_id: The id of the framework (required)
        :param bool include_schema: Whether to include each algorithm framework's JSON schema in the response.
        :return: AlgorithmFramework
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_algorithm_framework_with_http_info(framework_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_algorithm_framework_with_http_info(framework_id, **kwargs)  # noqa: E501
            return data

    def get_algorithm_framework_with_http_info(self, framework_id, **kwargs):  # noqa: E501
        """Get algorithm framework by frameworkId  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_framework_with_http_info(framework_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int framework_id: The id of the framework (required)
        :param bool include_schema: Whether to include each algorithm framework's JSON schema in the response.
        :return: AlgorithmFramework
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['framework_id', 'include_schema']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_algorithm_framework" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'framework_id' is set
        if self.api_client.client_side_validation and ('framework_id' not in params or
                                                       params['framework_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `framework_id` when calling `get_algorithm_framework`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'framework_id' in params:
            path_params['frameworkId'] = params['framework_id']  # noqa: E501

        query_params = []
        if 'include_schema' in params:
            query_params.append(('include_schema', params['include_schema']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/algorithm/frameworks/id/{frameworkId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AlgorithmFramework',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_algorithm_usage_report(self, algorithm_name, include_assignment_detail, **kwargs):  # noqa: E501
        """Generate a report listing all usage of an algorithm on the masking engine  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_usage_report(algorithm_name, include_assignment_detail, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str algorithm_name: The name of the algorithm (required)
        :param bool include_assignment_detail: Whether to include extended, human-readable algorithm assignment detail in the report. File and mainframe format usages are expanded to show each usage across environments, rulesets and files. The content and ordering of these details are subject to change. (required)
        :param list[int] environment_filter: Report only usage occurring within the specified environment(s). When the algorithm is used in a file format, all usage of that file format is reported so long as it is referenced by any environment matching the filter. Filtering by environment excludes all domain and algorithm reference usage.
        :param list[int] ruleset_filter: Report only usage occurring within the specified ruleset(s). When the algorithm is used in a file format, all usage of that file format is reported so long as it is referenced by any ruleset matching the filter. Filtering by ruleset excludes all domain and algorithm reference usage.
        :return: AlgorithmUsageReport
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_algorithm_usage_report_with_http_info(algorithm_name, include_assignment_detail, **kwargs)  # noqa: E501
        else:
            (data) = self.get_algorithm_usage_report_with_http_info(algorithm_name, include_assignment_detail, **kwargs)  # noqa: E501
            return data

    def get_algorithm_usage_report_with_http_info(self, algorithm_name, include_assignment_detail, **kwargs):  # noqa: E501
        """Generate a report listing all usage of an algorithm on the masking engine  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_usage_report_with_http_info(algorithm_name, include_assignment_detail, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str algorithm_name: The name of the algorithm (required)
        :param bool include_assignment_detail: Whether to include extended, human-readable algorithm assignment detail in the report. File and mainframe format usages are expanded to show each usage across environments, rulesets and files. The content and ordering of these details are subject to change. (required)
        :param list[int] environment_filter: Report only usage occurring within the specified environment(s). When the algorithm is used in a file format, all usage of that file format is reported so long as it is referenced by any environment matching the filter. Filtering by environment excludes all domain and algorithm reference usage.
        :param list[int] ruleset_filter: Report only usage occurring within the specified ruleset(s). When the algorithm is used in a file format, all usage of that file format is reported so long as it is referenced by any ruleset matching the filter. Filtering by ruleset excludes all domain and algorithm reference usage.
        :return: AlgorithmUsageReport
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['algorithm_name', 'include_assignment_detail', 'environment_filter', 'ruleset_filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_algorithm_usage_report" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'algorithm_name' is set
        if self.api_client.client_side_validation and ('algorithm_name' not in params or
                                                       params['algorithm_name'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `algorithm_name` when calling `get_algorithm_usage_report`")  # noqa: E501
        # verify the required parameter 'include_assignment_detail' is set
        if self.api_client.client_side_validation and ('include_assignment_detail' not in params or
                                                       params['include_assignment_detail'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `include_assignment_detail` when calling `get_algorithm_usage_report`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'algorithm_name' in params:
            path_params['algorithmName'] = params['algorithm_name']  # noqa: E501

        query_params = []
        if 'include_assignment_detail' in params:
            query_params.append(('includeAssignmentDetail', params['include_assignment_detail']))  # noqa: E501
        if 'environment_filter' in params:
            query_params.append(('environmentFilter', params['environment_filter']))  # noqa: E501
            collection_formats['environmentFilter'] = 'multi'  # noqa: E501
        if 'ruleset_filter' in params:
            query_params.append(('rulesetFilter', params['ruleset_filter']))  # noqa: E501
            collection_formats['rulesetFilter'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{algorithmName}/usage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AlgorithmUsageReport',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_algorithm_frameworks(self, **kwargs):  # noqa: E501
        """Get all algorithm frameworks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_algorithm_frameworks(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mask_type: Return only frameworks that mask the specified data type.
        :param bool include_schema: Whether to include each algorithm framework's JSON schema in the response.
        :param int page_number: The page number for which to get algorithm frameworks. This will default to the first page if excluded
        :param int page_size: The maximum number of objects to return. This will default to the DEFAULT_API_PAGE_SIZE property if not provided
        :return: AlgorithmFrameworkList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_algorithm_frameworks_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_algorithm_frameworks_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_algorithm_frameworks_with_http_info(self, **kwargs):  # noqa: E501
        """Get all algorithm frameworks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_algorithm_frameworks_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mask_type: Return only frameworks that mask the specified data type.
        :param bool include_schema: Whether to include each algorithm framework's JSON schema in the response.
        :param int page_number: The page number for which to get algorithm frameworks. This will default to the first page if excluded
        :param int page_size: The maximum number of objects to return. This will default to the DEFAULT_API_PAGE_SIZE property if not provided
        :return: AlgorithmFrameworkList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mask_type', 'include_schema', 'page_number', 'page_size']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_algorithm_frameworks" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'mask_type' in params:
            query_params.append(('mask_type', params['mask_type']))  # noqa: E501
        if 'include_schema' in params:
            query_params.append(('include_schema', params['include_schema']))  # noqa: E501
        if 'page_number' in params:
            query_params.append(('page_number', params['page_number']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/algorithm/frameworks/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AlgorithmFrameworkList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_algorithms(self, **kwargs):  # noqa: E501
        """Get all algorithms  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_algorithms(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mask_type: The data type of value this algorithm can mask.
        :param int page_number: The page number for which to get algorithms. This will default to the first page if excluded
        :param int page_size: The maximum number of objects to return. This will default to the DEFAULT_API_PAGE_SIZE property if not provided
        :return: AlgorithmList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_algorithms_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_algorithms_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_algorithms_with_http_info(self, **kwargs):  # noqa: E501
        """Get all algorithms  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_algorithms_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mask_type: The data type of value this algorithm can mask.
        :param int page_number: The page number for which to get algorithms. This will default to the first page if excluded
        :param int page_size: The maximum number of objects to return. This will default to the DEFAULT_API_PAGE_SIZE property if not provided
        :return: AlgorithmList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mask_type', 'page_number', 'page_size']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_algorithms" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'mask_type' in params:
            query_params.append(('mask_type', params['mask_type']))  # noqa: E501
        if 'page_number' in params:
            query_params.append(('page_number', params['page_number']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AlgorithmList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_available_migrations(self, **kwargs):  # noqa: E501
        """Get a list of all algorithms that support migration to a new framework  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_available_migrations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AlgorithmMigrationList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_available_migrations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_available_migrations_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_available_migrations_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of all algorithms that support migration to a new framework  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_available_migrations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AlgorithmMigrationList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_available_migrations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/migration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AlgorithmMigrationList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def migrate_algorithm(self, algorithm_name, new_algorithm_name, **kwargs):  # noqa: E501
        """Create a migrated copy of an existing legacy algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.migrate_algorithm(algorithm_name, new_algorithm_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str algorithm_name: The name of the algorithm to be migrated. (required)
        :param str new_algorithm_name: The name of the new algorithm to be created by the migration process. (required)
        :return: AsyncTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.migrate_algorithm_with_http_info(algorithm_name, new_algorithm_name, **kwargs)  # noqa: E501
        else:
            (data) = self.migrate_algorithm_with_http_info(algorithm_name, new_algorithm_name, **kwargs)  # noqa: E501
            return data

    def migrate_algorithm_with_http_info(self, algorithm_name, new_algorithm_name, **kwargs):  # noqa: E501
        """Create a migrated copy of an existing legacy algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.migrate_algorithm_with_http_info(algorithm_name, new_algorithm_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str algorithm_name: The name of the algorithm to be migrated. (required)
        :param str new_algorithm_name: The name of the new algorithm to be created by the migration process. (required)
        :return: AsyncTask
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['algorithm_name', 'new_algorithm_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method migrate_algorithm" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'algorithm_name' is set
        if self.api_client.client_side_validation and ('algorithm_name' not in params or
                                                       params['algorithm_name'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `algorithm_name` when calling `migrate_algorithm`")  # noqa: E501
        # verify the required parameter 'new_algorithm_name' is set
        if self.api_client.client_side_validation and ('new_algorithm_name' not in params or
                                                       params['new_algorithm_name'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `new_algorithm_name` when calling `migrate_algorithm`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'algorithm_name' in params:
            path_params['algorithmName'] = params['algorithm_name']  # noqa: E501

        query_params = []
        if 'new_algorithm_name' in params:
            query_params.append(('newAlgorithmName', params['new_algorithm_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{algorithmName}/migration', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def randomize_algorithm_key(self, algorithm_name, **kwargs):  # noqa: E501
        """Randomize algorithm key by name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.randomize_algorithm_key(algorithm_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str algorithm_name: The name of the algorithm who's key should be randomized (required)
        :return: Algorithm
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.randomize_algorithm_key_with_http_info(algorithm_name, **kwargs)  # noqa: E501
        else:
            (data) = self.randomize_algorithm_key_with_http_info(algorithm_name, **kwargs)  # noqa: E501
            return data

    def randomize_algorithm_key_with_http_info(self, algorithm_name, **kwargs):  # noqa: E501
        """Randomize algorithm key by name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.randomize_algorithm_key_with_http_info(algorithm_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str algorithm_name: The name of the algorithm who's key should be randomized (required)
        :return: Algorithm
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['algorithm_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method randomize_algorithm_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'algorithm_name' is set
        if self.api_client.client_side_validation and ('algorithm_name' not in params or
                                                       params['algorithm_name'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `algorithm_name` when calling `randomize_algorithm_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'algorithm_name' in params:
            path_params['algorithmName'] = params['algorithm_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{algorithmName}/randomize-key', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Algorithm',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_algorithm(self, algorithm_name, body, **kwargs):  # noqa: E501
        """Update algorithm by name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_algorithm(algorithm_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str algorithm_name: The name of the algorithm to update (required)
        :param Algorithm body: The updated algorithm (required)
        :return: AsyncTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_algorithm_with_http_info(algorithm_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_algorithm_with_http_info(algorithm_name, body, **kwargs)  # noqa: E501
            return data

    def update_algorithm_with_http_info(self, algorithm_name, body, **kwargs):  # noqa: E501
        """Update algorithm by name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_algorithm_with_http_info(algorithm_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str algorithm_name: The name of the algorithm to update (required)
        :param Algorithm body: The updated algorithm (required)
        :return: AsyncTask
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['algorithm_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_algorithm" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'algorithm_name' is set
        if self.api_client.client_side_validation and ('algorithm_name' not in params or
                                                       params['algorithm_name'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `algorithm_name` when calling `update_algorithm`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_algorithm`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'algorithm_name' in params:
            path_params['algorithmName'] = params['algorithm_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{algorithmName}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_algorithm_usage(self, algorithm_name, replacement_algorithm_name, ignore_incompatible_types, **kwargs):  # noqa: E501
        """Update ALL usage on the engine of the chosen algorithm to the replacement algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_algorithm_usage(algorithm_name, replacement_algorithm_name, ignore_incompatible_types, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str algorithm_name: The name of the algorithm (required)
        :param str replacement_algorithm_name: The name of the replacement algorithm (required)
        :param bool ignore_incompatible_types: Update usage even when the original and new algorithms have incompatible masking types. (required)
        :param list[int] environment_filter: Only update usage occurring within the specified environment(s). When an environment filter is applied, domain and algorithm reference usage is not updated. This operation will fail if any file format referencing the algorithm is used from environments that don't match the filter.
        :param list[int] ruleset_filter: Only update usage occurring within the specified ruleset(s). When a ruleset filter is applied, domain and algorithm reference usage is not updated. This operation will fail if any file format referencing the algorithm is used from rulesets that don't match the filter.
        :return: AlgorithmUsageReport
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_algorithm_usage_with_http_info(algorithm_name, replacement_algorithm_name, ignore_incompatible_types, **kwargs)  # noqa: E501
        else:
            (data) = self.update_algorithm_usage_with_http_info(algorithm_name, replacement_algorithm_name, ignore_incompatible_types, **kwargs)  # noqa: E501
            return data

    def update_algorithm_usage_with_http_info(self, algorithm_name, replacement_algorithm_name, ignore_incompatible_types, **kwargs):  # noqa: E501
        """Update ALL usage on the engine of the chosen algorithm to the replacement algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_algorithm_usage_with_http_info(algorithm_name, replacement_algorithm_name, ignore_incompatible_types, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str algorithm_name: The name of the algorithm (required)
        :param str replacement_algorithm_name: The name of the replacement algorithm (required)
        :param bool ignore_incompatible_types: Update usage even when the original and new algorithms have incompatible masking types. (required)
        :param list[int] environment_filter: Only update usage occurring within the specified environment(s). When an environment filter is applied, domain and algorithm reference usage is not updated. This operation will fail if any file format referencing the algorithm is used from environments that don't match the filter.
        :param list[int] ruleset_filter: Only update usage occurring within the specified ruleset(s). When a ruleset filter is applied, domain and algorithm reference usage is not updated. This operation will fail if any file format referencing the algorithm is used from rulesets that don't match the filter.
        :return: AlgorithmUsageReport
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['algorithm_name', 'replacement_algorithm_name', 'ignore_incompatible_types', 'environment_filter', 'ruleset_filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_algorithm_usage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'algorithm_name' is set
        if self.api_client.client_side_validation and ('algorithm_name' not in params or
                                                       params['algorithm_name'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `algorithm_name` when calling `update_algorithm_usage`")  # noqa: E501
        # verify the required parameter 'replacement_algorithm_name' is set
        if self.api_client.client_side_validation and ('replacement_algorithm_name' not in params or
                                                       params['replacement_algorithm_name'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `replacement_algorithm_name` when calling `update_algorithm_usage`")  # noqa: E501
        # verify the required parameter 'ignore_incompatible_types' is set
        if self.api_client.client_side_validation and ('ignore_incompatible_types' not in params or
                                                       params['ignore_incompatible_types'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ignore_incompatible_types` when calling `update_algorithm_usage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'algorithm_name' in params:
            path_params['algorithmName'] = params['algorithm_name']  # noqa: E501

        query_params = []
        if 'replacement_algorithm_name' in params:
            query_params.append(('replacementAlgorithmName', params['replacement_algorithm_name']))  # noqa: E501
        if 'ignore_incompatible_types' in params:
            query_params.append(('ignoreIncompatibleTypes', params['ignore_incompatible_types']))  # noqa: E501
        if 'environment_filter' in params:
            query_params.append(('environmentFilter', params['environment_filter']))  # noqa: E501
            collection_formats['environmentFilter'] = 'multi'  # noqa: E501
        if 'ruleset_filter' in params:
            query_params.append(('rulesetFilter', params['ruleset_filter']))  # noqa: E501
            collection_formats['rulesetFilter'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{algorithmName}/usage', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AlgorithmUsageReport',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_algorithm(self, body, **kwargs):  # noqa: E501
        """Validate algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_algorithm(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Algorithm body: The algorithm to validate (required)
        :return: AlgorithmValidation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.validate_algorithm_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.validate_algorithm_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def validate_algorithm_with_http_info(self, body, **kwargs):  # noqa: E501
        """Validate algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_algorithm_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Algorithm body: The algorithm to validate (required)
        :return: AlgorithmValidation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_algorithm" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `validate_algorithm`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/validate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AlgorithmValidation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
